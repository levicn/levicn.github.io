---
layout:     post
title:      老生常谈消息转发
subtitle:   Talk about forward message
date:       2019-02-19
header-img: img/post-bg-blog.jpg
author:     Levi
catalog:    true
tags:
    - iOS
    - 消息转发
---

### 解决三个问题

- 消息转发是什么？
- 消息转发的应用场景是什么？
- 类方法怎样进行消息转发？

### 消息转发是什么

`NSObject`提供的四个方法，或者叫四个步骤：

```
// 动态方法解析
+ (BOOL)resolveClassMethod:(SEL)sel;
+ (BOOL)resolveInstanceMethod:(SEL)sel;
```

```
// 备援选择
- (id)forwardingTargetForSelector:(SEL)aSelector
```

```
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
```

```
// 完整消息转发
- (id)forwardingTargetForSelector:(SEL)aSelector
```

动态方法解析、备援选择、完整消息转发，这些都不是人话，翻译一下：

- 动态方法解析： 崩溃前给你一个机会动态添加方法。
- 备援选择： 大哥！我扛不住了，你上吧。
- 完整消息转发： 再给你最后一个机会！

如果这些机会你都错过了，会进入`NSObject`的这个方法：

```
- (void)doesNotRecognizeSelector:(SEL)aSelector;
```

机智的你一定会想，我在这个方法里处理，起码不是解决了崩溃的问题吗？

没错，这样是可以解决崩溃问题，但是请看iOS开发文档里的这段说明：

>*If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown.*

还是好好听话，不要想入非非了，规范很重要。

### 如何动态添加方法

```
// 定义
class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, 
                const char * _Nullable types) 
```

```
// 用例
class_addMethod(self, sel, (IMP)yourMethod, "v");
```

`(IMP)yourMethod`可以用`method_getImplementation(yourMethod)`

`"v"`是方法描述，代表返回值是void类型，可以用`method_getTypeEncoding(yourMethod)`代替。

```
// 获取方法的IMP指针
OBJC_EXPORT IMP _Nonnull
method_getImplementation(Method _Nonnull m) 
```

```
// 获取方法描述
OBJC_EXPORT const char * _Nullable
method_getTypeEncoding(Method _Nonnull m) 
```

两个方法都由runtime提供，参数是`objc_method`对象。

### NSInvovation如何使用

NSInvovation是什么？精简一下iOS开发文档的解释：

- 用于在对象之间转发消息。消息中的所有元素（目标，选择器，参数和返回值）都可以设置
- 一个对象可以派发到不同的目标，灵活性高
- 不支持可变参数，要用方法签名来初始化
- 不持有调用的参数

是否有点懵逼？我们来看一下实际使用：

```
//根据方法创建方法签名
NSMethodSignature *sign = [[self class] instanceMethodSignatureForSelector:@selector(sumNumber1:number2:)];

//根据方法签名创建invocation
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sign];

//设置调用对象相关信息
invocation.target = self;
invocation.selector = @selector(sumNumber1:number2:);
NSInteger number1 = 30;
NSInteger number2 = 10;
[invocation setArgument:&number1 atIndex:2];
[invocation setArgument:&number2 atIndex:3];

//触发调用
[invocation invoke];

//获取返回值
NSNumber *sum = nil;
[invocation getReturnValue:&sum];
```

需注意的点：

- 获取方法签名的对象可以是类或实例对象
- `setArgument`的索引从2开始，因为前两个参数是target和_cmd

`NSInvovation`和`performSelector:withObject:`方法都可以直接给某个对象发送消息（不引用头文件的情况直接调用方法，绕过编译器检测），但是相比起来：

- NSInvocation可以应用于大于两个参数的情况
- NSInvocation可以应用于返回值为基本类型的方法

所以，NSInvocation使用起来要更加灵活。

### 消息转发的流程

先用伪代码来解释一下：

```
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == 某个处理不了的sel) {
        动态添加一个方法
        return YES;
    }
    return NO;
}
```

```
- (id)forwardingTargetForSelector:(SEL)sel
{
    if (sel == 某个处理不了的sel) {
        // 返回可以处理该消息的对象，把消息交给此对象处理
        return someObject;
    }
    // 返回nil或self或继续执行消息转发流程
    return nil;
}
```

```
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
    // 返回后续流程初始化NSInvocation的方法签名
    // 实现了此方法才会进入后续forwardInvocation方法，否则forwardInvocation不会执行
    return someSignature;
}
```

```
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    // 使用anInvocationl来转发消息
    [anInvocation invokeWithTarget:someTarget];
}
```

```
- (void)doesNotRecognizeSelector:(SEL)sel
{
    // 消息没有得到处理 崩溃退出
    [super doesNotRecognizeSelector:aSelector];
}
```

简图：

![img](/img/in-post/msg_forward_sim.png)

完整流程图：

![img](/img/in-post/msg_forward_com.jpg)